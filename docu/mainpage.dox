// Licensed under 3-Clause BSD, see License.txt

/// @defgroup TestRunnerAndHelper Helper functions
/// Runner and helper functions

/// @defgroup Assertions Test Assertions
/// Test assertions for variables, strings, waves and helper functions

/// @defgroup assertionFlags Assertions flags
/// Constants for assertion test tuning

/// @defgroup testWaveFlags Wave existence flags
/// Values for @c majorType / @c minorType of @ref WARN_WAVE, @ref CHECK_WAVE and @ref REQUIRE_WAVE

/// @defgroup equalWaveFlags Wave equality flags
/// Values for @c mode in @ref WARN_EQUAL_WAVES, @ref CHECK_EQUAL_WAVES and @ref REQUIRE_EQUAL_WAVES

/**

@mainpage

This package empowers a programmer to utilize unit testing for Igor Pro procedures and XOPs.
For a quick start have a look at the [first example](@ref example1).

The basic building blocks of this package are [Assertions](@ref secAssertionTypes) (for checking if an entity fullfills specific properties), [Test Cases](@ref secTestCase) (group of assertions) and [Test Suites](@ref secTestSuite) (group of test cases).

Interface design and naming is inspired by the [Boost Test Library](http://www.boost.org/libs/test).

@section secAssertionTypes Assertion Types

An assertion checks that a given condition is true. Or in more general terms that an entity fullfills specific properties. Test assertions are defined for strings, variables and waves and have ALL CAPS names. They usually come in tripletts which differ only in how they react on a failed assertion. Comparing two variables for example can be done with @ref WARN_EQUAL_VAR, @ref CHECK_EQUAL_VAR or @ref REQUIRE_EQUAL_VAR.
@par
The following table summarizes the action on a failed assertion:
<table border>
<tr>
  <td>Type</td>
  <td>Create Log Message</td>
  <td>Increment Error Count</td>
  <td>Abort execution immediately</td>
</tr>
<tr>
  <td>WARN</td>
  <td>YES</td>
  <td>NO</td>
  <td>NO</td>
</tr>
<tr>
  <td>CHECK</td>
  <td>YES</td>
  <td>YES</td>
  <td>NO</td>
</tr>
<tr>
  <td>REQUIRE</td>
  <td>YES</td>
  <td>YES</td>
  <td>YES</td>
</tr>
</table>

If in doubt use the CHECK variant. For the sake of clarity only the CHECK variants are documented, as the interface for REQUIRE and WARN is equivalent.
The assertions with only one variant are @ref PASS and @ref FAIL, see also @ref example7.
@section secTestCase Test Case

A test case is one of the basic building blocks grouping assertions together. A function is considered a test case if it fullfills all of the following properties:
- takes no parameters
- its name does not end on _IGNORE
- is either non-static or static and part of a regular module

The second rule allows advanced users to add their own helper functions. It is advised to define all test cases as static functions and to create one regular distinctive module per procedure file.

A single test case from a test suite can be run using the optional @c testCase parameter of @ref RunTest. This is also true when multiple test suites are executed in a test run and each has such a test case.
If the given test case does not exist in any test suite it is treated as error.

Example: In test suite \p TestSuite_1.ipf test cases \p static \p Step1 and \p static \p Step2 are defined and in test suite \p TestSuite_2.ipf test cases \p static \p Step1 , \p static \p Step2 and \p static \p Step3 are defined.
Calling \code Runtest("TestSuite_1.ipf;TestSuite_2.ipf", testCase="Step1") \endcode executes two test cases, \p Step1 in test suite 1 and \p Step1 in test suite 2.

@section secTestSuite Test Suite

A test suite is a group of test cases which should belong together and is equal to a procedure file. Therefore tests suites can not be nested, although multiple test suites can be run with one command using the parameter @c procWinList of @ref RunTest.

@section secTestHooks Test Hooks

A test run can be extended with user-defined code at specific points during its execution.
These pre-defined injection points are at the beginning and respectively at the end of a complete Test Run, a @ref secTestSuite, and a @ref secTestCase.

The following functions are reserved for user code injections:
<table border>
  <tr>
    <td>@code TEST_BEGIN_OVERRIDE(string name) @endcode</td>
    <td>Executed at the begin of a test run

     \p name is a string that will hold the name of the current test</td>
  </tr>
  <tr>
    <td>@code TEST_END_OVERRIDE(string name) @endcode</td>
    <td>Executed at the end of a test run

     \p name is a string that will hold the name of the current test

    note: As this function is executed at the very end of a test run the Igor debugger state is already reset to the state it had before RunTest was executed.</td>
  </tr>
  <tr>
    <td>@code TEST_SUITE_BEGIN_OVERRIDE(string testSuiteName)@endcode</td>
    <td>Executed at the begin of a test suite (test functions that are defined within a single procedure)

     \p TestSuiteName is a string that will hold the name of the current @ref secTestSuite (procedure name)

     This function can also be defined locally in a test suite with the \p static keyword.</td>
  </tr>
  <tr>
    <td>@code TEST_SUITE_END_OVERRIDE(string testSuiteName)@endcode</td>
    <td>Executed at the end of a test suite (test functions that are defined within a single procedure)

     \p TestSuiteName is a string that will hold the name of the current @ref secTestSuite (procedure name)

     This function can also be defined locally in a test suite with the \p static keyword.</td>
  </tr>
  <tr>
    <td>@code TEST_CASE_BEGIN_OVERRIDE(string testCaseName)@endcode</td>
    <td>Executed at the begin of a test case

     \p TestCaseName is a string that will hold the name of the current @ref secTestCase (function name)

     This function can also be defined locally in a test suite with the \p static keyword.</td>
  </tr>
  <tr>
    <td>@code TEST_CASE_END_OVERRIDE(string testCaseName)@endcode</td>
    <td>Executed at the end of a test case

     \p TestCaseName is a string that will hold the name of the current @ref secTestCase (function name)

     This function can also be defined locally in a test suite with the \p static keyword.</td>
  </tr>
</table>

These functions are executed automatically if they are defined anywhere in global or local context. For example, \p TEST_CASE_BEGIN_OVERRIDE gets executed at the beginning of each test case.
Locally defined functions always override globally defined ones of the same name. To visualize this behavior, take a look at the following scenario:
A user would like to have code executed only in a specific @ref secTestSuite.
Then the functions \p TEST_SUITE_BEGIN_OVERRIDE and \p TEST_SUITE_END_OVERRIDE can be defined locally within the current @ref secTestSuite by declaring them \p static to the @ref secTestSuite. The local (static) functions then replace any previously defined global functions.
The functionality with additional user code at certain points of a test run is demonstrated in @ref example5.

If the locally defined function should only extend a global function the user can call the global function within the local function as follows:
@latexonly
\begin{minted}{igor}
FUNCREF USER_HOOK_PROTO tcbegin_global = TEST_CASE_BEGIN_OVERRIDE
tcbegin_global(TestCaseName)
\end{minted}
@endlatexonly

To give a possible use case:
By default, each @ref secTestCase is executed in its own temporary data folder. \p TEST_CASE_BEGIN_OVERRIDE can now be used to set the data folder to \p root: such that each test case gets executed in root and no cleanup is done afterward. The next test case then starts with the data the previous test case left in \p root:.

Note that by default the Igor debugger is disabled during the execution of a test run.

@section secJUNIT JUNIT Output

The igor unit testing framework supports output of test run results in JUNIT compatible format. The output can be enabled by adding the optional parameter `enableJU=1` to `RunTest`.
The XML output files are written to the experiments `home` directory with naming `JU_Experiment_Date_Time.xml`. If a file with the same name already exists a three digit number is added to the name.
The JUNIT Output also contains the history log of each test case and test suite.

@section secTAPOutput Test Anything Protocol Output

Output according to the Test Anything Protocol (TAP) standard 13 can be enabled with the optional parameter enableTAP = 1 of @ref RunTest. The output is written into a file in the experiment folder with a unique generated name tap_'time'.log.
This prevents accidental overwrites of previous test runs. A TAP output file combines all Test Cases from all Test Suites given in @ref RunTest.<br>
Additional TAP compliant descriptions and directives for each Test Case can be added in the two lines preceding the function of a Test Case.
@latexonly
\begin{minted}{igor}
// #TAPDescription: My description here
// #TAPDirective: My directive here
\end{minted}
@endlatexonly

For directives two additional key words are defined that can be written at the beginning of the directive message.<br>
- @code TODO @endcode indicates a Test that includes a part of the program still in development. Failures here will be ignores by a TAP consumer.
- @code SKIP @endcode indicates a Test that should be skipped. A test with this directive key word is not executed and reported always as 'ok'.

Examples:
@latexonly
\begin{minted}{igor}
// #TAPDirective: TODO routine that should be tested is still under development
\end{minted}
@endlatexonly
or
@latexonly
\begin{minted}{igor}
// #TAPDirective: SKIP this test gets skipped
\end{minted}
@endlatexonly

See the Experiment in the TAP_Example folder for reference.

@section secOptionalparameters Optional Parameters for RunTest

<table border>
  <tr>
    <td>@code enableJU = 1@endcode</td>
    <td>A JUNIT compatible XML file is written at the end of the test run. It allows the combination of this framework with continious integration servers like Atlassian Bamboo.</td>
  </tr>
  <tr>
    <td>@code enableTAP = 1@endcode</td>
    <td>A Test Anything Protocol (TAP) version 13 compatible file is written at the end of the test run.</td>
  </tr>
  <tr>
    <td>@code enableRegExp = 1@endcode</td>
    <td>RunTest will treat the input procedure list as a regular expressions. <p>Example:@code RunTest("example[1-3]-plain\.ipf", enableRegExp=1)@endcode will run the test files @c example1-plain.ipf @c example2-plain.ipf and @c example3-plain.ipf from the directory docu/examples with a single command.</td>
  </tr>
  <tr>
    <td>@code allowDebug = 1@endcode</td>
    <td>RunTest will leave the Igor debugger in its current state. This is useful for a brief look where user code generates an exception.</td>
  </tr>
  <tr>
    <td>@code keepDataFolder = 1@endcode</td>
    <td>The temporary data folder wherein each test case is executed is not cleaned up at the end of the test case. This allows to review the data produced.</td>
  </tr>
</table>

@section secAutomaticExecution Automate Test Runs

To further simplify test execution it is possible to automate test runs from the command line.<br>
Steps to do that include:
- Implement a function called @c run in ProcGlobal context taking no parameters. This function must perform all necessary steps for test execution, which is at least one call to @ref RunTest.
- Put the test experiment together with your test suites (procedure files) and the script helper/autorun-test.bat into its own folder
- Run the batch file autorun-test.bat
- Inspect the created log file

The example batch files for autorun create a file named @c DO_AUTORUN.TXT
before starting Igor Pro. This enables autorun mode. After the @c run function
is executed and returned the log is saved in a file on disk and Igor Pro quits.

A different autorun mode is enabled if the file is named @c
DO_AUTORUN_PLAIN.TXT. In this mode no log file is saved after the test
execution and Igor Pro does not quit. This mode also does not use the Operation
Queue.

See also @ref example6.

@section secIndependentModuleSupport Running in an independent module

The unit-testing framework can be run itself in an independent module. This can
be required in very rare cases when the ProcGlobal procedures might not always be compiled.

See also @ref example9.

@section secAbortCondition Handling of Abort code

The unit-testing framework continues with the next test case after catching @c Abort and logs the abort code.
Currently differentiation of different abort conditions include manual user aborts, stack overflow and an encountered @c Abort in the code.
When manually pressing the Abort button the framework is terminated.

note: Igor Pro 6 can not differentiate between manual user aborts and programmatic abort codes. Pressing the Abort button in Igor Pro 6 will therefore terminate only the current test case and continue with the next queued test case.

@page secExamples Example Documentation

@section example1 example1-plain.ipf
Test suite showing the basic working principles.
@latexonly
\includeexample{example1-plain.ipf}
@endlatexonly

@section example2 example2-plain.ipf
Test suite with run routine and module/static usage. See the section about [test cases](@ref secTestCase) why the function run_IGNORE() is not considered a test case.
@latexonly
\includeexample{example2-plain.ipf}
@endlatexonly

@section example3 example3-plain.ipf
Test suite emphasising the difference between the WARN(), CHECK() and REQUIRE() assertion variants.
@latexonly
\includeexample{example3-plain.ipf}
@endlatexonly
See also @ref secAssertionTypes.

@section example4 example4-wavechecking.ipf
Test suite showing some test assertions Xfor waves.
@latexonly
\includeexample{example4-wavechecking.ipf}
@endlatexonly

@section example5 example5-extensionhooks.ipf
Two test suites showing how to use test hook overrides.
@latexonly
\includeexample{example5-extensionhooks.ipf}
\includeexample{example5-extensionhooks-otherSuite.ipf}
@endlatexonly

@section example6 example6-automatic-invocation.ipf
Test suite showing how to automate testing from the command line.
See also @ref secAutomaticExecution.
@latexonly
\includeexample{Example6/example6-automatic-invocation.ipf}
\includeexample{Example6/example6-runner.ipf}
@endlatexonly

@section example7 example7-uncaught-aborts.ipf
Test suite showing how unhandled aborts in test cases are handled.
@latexonly
\includeexample{example7-uncaught-aborts.ipf}
@endlatexonly

@section example8 example8-uncaught-runtime-errors.ipf
Test suite showing how runtime errors are treated.
@latexonly
\includeexample{example8-uncaught-runtime-errors.ipf}
@endlatexonly

@section example9 example9-IM.ipf
Test suite showing how running the whole framework in an independent module works.
@latexonly
\includeexample{example9-IM.ipf}
@endlatexonly

**/
