Igor Unit Testing Framework
===========================
This package empowers a programmer to utilize unit testing for Igor Pro procedures and XOPs.
For a quick start have a look at the :ref:`first example<example1>`

The basic building blocks of this package are
:ref:`Assertions <AssertionTypes>` (for checking if an entity fullfills specific properties),
:ref:`Test Cases <TestCase>` (group of assertions) and
:ref:`Test Suites <TestSuite>` (group of test cases).

Interface design and naming is inspired by the
`Boost Test Library <http://www.boost.org/libs/test>`__.
See :ref:`genindex` or :ref:`modindex` for a list of all objects
or use :ref:`search` to search for an exact term.

.. _AssertionTypes:

Assertion Types
---------------

An assertion checks that a given condition is true. Or in more general terms that an entity fullfills specific properties. Test assertions are defined for strings, variables and waves and have `ALL CAPS` names.
They usually come in tripletts which differ only in how they react on a failed assertion. Comparing two variables for example can be done with :cpp:func:`WARN_EQUAL_VAR()`, or :cpp:func:`REQUIRE_EQUAL_VAR()`.

The following table summarizes the action on a failed assertion:

+-----------+----------------------+-------------------------+-------------------------------+
| Type      | Create Log Message   | Increment Error Count   | Abort execution immediately   |
+===========+======================+=========================+===============================+
| WARN      | YES                  | NO                      | NO                            |
+-----------+----------------------+-------------------------+-------------------------------+
| CHECK     | YES                  | YES                     | NO                            |
+-----------+----------------------+-------------------------+-------------------------------+
| REQUIRE   | YES                  | YES                     | YES                           |
+-----------+----------------------+-------------------------+-------------------------------+

If in doubt use the CHECK variant.

.. todo::
   document all `REQUIRE_*` and `WARN_*` Methods byRef to their corresponding `CHECK_` variants for better output on doxygen/sphinx.
   This is also useful for deleting the following info and makes the code more clear.
   See doxygen flag `EXTRACT_ALL = YES`

.. note::
   For the sake of clarity only the `CHECK_*` variants are documented, as the interface for `REQUIRE_*` and `WARN_*` is equivalent.

See :ref:`AssertionTypes` for a clarification of the difference between the three assertion types.
The assertions with only one variant are :cpp:func:`PASS()` and :cpp:func:`FAIL`, see also :ref:`example7`.

 .. _TestCase:

Test Case
---------

A Test Case is one of the basic building blocks grouping assertions together.
A function is considered a test case if it fullfills all of the following properties:

- takes no parameters
- its name does not end on `_IGNORE`
- is either non-static or static and part of a regular module

The second rule is reserving the `_IGNORE` namespace to allow advanced users to add their own helper functions.
It is advised to define all test cases as static functions and to create one regular distinctive module per procedure file.
This will separate the Test Case to its own namespace not interfering with user-defined functions in `ProcGlobal`.

A single :ref:`TestCase` from a :ref:`TestSuite` can be run using the optional parameter `testCase` of :cpp:func:`RunTest()`

.. todo::
   function output can be generated by doxygenfunction directive:
   `.. doxygenfunction:: RunTest`
   reference the optional parameter to parameter defined in the doxygen/breathe code to avoid outputting the whole function here.

This is also true when multiple :ref:`Test Suites<TestSuite>` are executed in a :cpp:func:`Test Run <RunTest()>` and each has such a :ref:`TestCase`.

Example:
^^^^^^^^

In Test Suite `TestSuite_1.ipf` Test Cases `static Duplicate()` and `static Unique_1()` are defined.
In Test Suite `TestSuite_2.ipf` Test Cases `static Duplicate()`, `static Unique_2()` are defined.

.. code-block:: igor

   Runtest("TestSuite_1.ipf;TestSuite_2.ipf", testCase="Step1")

The command will run the two :ref:`Test Suites<TestSuite>`: `TestSuite_1.ipf` and `TestSuite_2.ipf` separately.
Within these Test Suites the `Unique*` Test Cases and the `Duplicate` Test Case is executed. the `Duplicate` Test Cases do not interfere with each other. They are called separately within both Test Suites.

.. note::
   if the given test case does not exist in any test suite it is treated as error.

.. _TestSuite:

Test Suite
----------

A Test Suite is a group of :ref:`Test Cases<TestCase>` which should belong together.
All :ref:`test functions<TestCase>` are defined in a single procedure file.
Generally speaking, a Test Suite is equal to a procedure file.
Therefore tests suites can not be nested, although multiple test suites can be run with one command using the parameter + `procWinList` of :cpp:func:`RunTest()`

.. todo::
   add ref to parameter procWinList using breathe

.. _TestHooks:

Test Hooks
----------

A Test Run can be extended with user-defined code at specific points during its execution.
These pre-defined injection points are at the beginning and respectively at the end of a complete :cpp:func:`Test Run<RunTest()>`, a :ref:`TestSuite`, and a :ref:`TestCase`.

The following functions are reserved for user code injections:

.. cpp:function:: TEST_BEGIN_OVERRIDE(string testName)

Executed at the **begin** of a :cpp:func:`Test Run<RunTest()>`.

.. cpp:function:: TEST_END_OVERRIDE(string testName)

Executed at the **end** of a :cpp:func:`Test Run<RunTest()>`.

.. cpp:function:: TEST_SUITE_BEGIN_OVERRIDE(string testSuite)

Executed at the **begin** of a :ref:`TestSuite`.

.. cpp:function:: TEST_SUITE_END_OVERRIDE(string testSuite)

Executed at the **end** of a :ref:`TestSuite`.

.. cpp:function:: TEST_CASE_BEGIN_OVERRIDE(string testSuite)

Executed at the **begin** of a :ref:`TestCase`.

.. cpp:function:: TEST_CASE_END_OVERRIDE(string testSuite)

Executed at the **end** of a :ref:`TestCase`.

.. note::
   As :cpp:func:`TEST_END_OVERRIDE()` is executed at the very end of a test run so that the Igor debugger state is already reset to the state it had before :cpp:func:`RunTest()` was executed.

.. note::
   The functions :cpp:func:`TEST_SUITE_BEGIN_OVERRIDE()` and :cpp:func:`TEST_SUITE_END_OVERRIDE()`
   as well as :cpp:func:`TEST_CASE_BEGIN_OVERRIDE()` and :cpp:func:`TEST_CASE_END_OVERRIDE()` can
   also be defined locally in a test suite with the `static` keyword.
   :ref:`example2` shows how `static` functions are called the framework.

These functions are executed automatically if they are defined anywhere in global or local context.
For example, :cpp:func:`TEST_CASE_BEGIN_OVERRIDE` gets executed at the beginning of each :ref:`TestCase`.
Locally defined functions always override globally defined ones of the same name.
To visualize this behavior, take a look at the following scenario:
A user would like to have code executed only in a specific :ref:`TestSuite`.
Then the functions :cpp:func:`TEST_SUITE_BEGIN_OVERRIDE` and :cpp:func:`TEST_SUITE_END_OVERRIDE` can be defined locally within the current :ref:`TestSuite` by declaring them  `static` to the current Test Suite.
The local (`static`) functions then replace any previously defined global functions.
The functionality with additional user code at certain points of a Test Run is demonstrated in :ref:`example5`.

.. note::
   If the locally defined function should only extend a global function the user can call the global function within the local function as follows:

   .. code-block:: igor

      FUNCREF USER_HOOK_PROTO tcbegin_global = TEST_CASE_BEGIN_OVERRIDE
      tcbegin_global(TestCaseName)

To give a possible use case, take a look at the following scenario:
By default, each :ref:`TestCase` is executed in its own temporary data folder.
:cpp:func:`TEST_CASE_BEGIN_OVERRIDE` can be used to set the data folder to `root:`.
This will result that each Test Case gets executed in `root:` and no cleanup is done afterward.
The *next* Test Case then starts with the data the *previous* Test Case left in `root:`.

.. todo::
   Add code of the replacement hook to the above use case.

.. note::
   By default the Igor debugger is disabled during the execution of a test run.

JUNIT Output
------------

The igor unit testing framework supports output of test run results in JUNIT compatible format. The output can be enabled by adding the optional parameter `enableJU=1` to :cpp:func:`RunTest()`.
The XML output files are written to the experiments `home` directory with naming `JU_Experiment_Date_Time.xml`. If a file with the same name already exists a three digit number is added to the name.
The JUNIT Output also contains the history log of each test case and test suite.

.. todo::
   reference function parameters with their breathe links

Test Anything Protocol Output
-----------------------------

Output according to the `Test Anything Protocol (TAP) standard 13 <https://testanything.org/tap-version-13-specification.html>`__ can be enabled with the optional parameter `enableTAP = 1` of :cpp:func:`RunTest()`.

.. todo::
   reference function parameters with their breathe links

The output is written into a file in the experiment folder with a unique generated name `tap_'time'.log`.
This prevents accidental overwrites of previous test runs.
A TAP output file combines all Test Cases from all Test Suites given in :cpp:func:`RunTest()`.
Additional TAP compliant descriptions and directives for each Test Case can be added in the two lines preceding the function of a Test Case:

.. code-block:: igor

   // #TAPDescription: My description here
   // #TAPDirective: My directive here

For directives two additional key words are defined that can be written at the beginning of the directive message.

- `TODO` indicates a Test that includes a part of the program still in development. Failures here will be ignores by a TAP consumer.
- `SKIP` indicates a Test that should be skipped. A Test with this directive key word is not executed and reported always as 'ok'.

Examples:
^^^^^^^^^

.. code-block:: igor

   // #TAPDirective: TODO routine that should be tested is still under development

or

.. code-block:: igor

   // #TAPDirective: SKIP this test gets skipped

See the Experiment in the TAP_Example folder for reference.

.. todo::
   add reference to the example, include example code

Optional Parameters for RunTest
-------------------------------

+----------------------+------------------------------------------------------------------------------+
| Parameter            | Description                                                                  |
+======================+==============================================================================+
| `enableJU = 1`       | A JUNIT compatible XML file is                                               |
|                      | written at the end of the Test Run.                                          |
|                      | It allows the combination of this                                            |
|                      | framework with continious                                                    |
|                      | integration servers like Atlassian                                           |
|                      | Bamboo.                                                                      |
+----------------------+------------------------------------------------------------------------------+
| `enableTAP = 1`      | A  `Test Anything Protocol (TAP) <https://testanything.org>`__               |
|                      | `standard 13 <https://testanything.org/tap-version-13-specification.html>`__ |
|                      | compatible file is                                                           |
|                      | written at the end of the test run.                                          |
+----------------------+------------------------------------------------------------------------------+
| `enableRegExp = 1`   | RunTest will treat the input                                                 |
|                      | procedure list as regular expressions.                                       |
|                      | Example:                                                                     |
|                      | `RunTest("example[1-3]-plain\\.ipf", enableRegExp=1)`                        |
|                      | will run the                                                                 |
|                      | test files :ref:`example1-plain.ipf<example1>`                               |
|                      | :ref:`example2-plain.ipf<example2>` and                                      |
|                      | :ref:`example3-plain.ipf<example3>`                                          |
|                      | with a single command.                                                       |
+----------------------+------------------------------------------------------------------------------+
| `allowDebug = 1`     | RunTest will leave the Igor debugger                                         |
|                      | in its current state.                                                        |
|                      | for a brief look where user code                                             |
|                      | generates an exception.                                                      |
+----------------------+------------------------------------------------------------------------------+
| `keepDataFolder = 1` | The temporary data folder wherein                                            |
|                      | each test case is executed is not                                            |
|                      | cleaned up at the end of the test                                            |
|                      | case. This allows to review the data                                         |
|                      | produced.                                                                    |
+----------------------+------------------------------------------------------------------------------+

Automate Test Runs
------------------

To further simplify test execution it is possible to automate test runs from the command line.

Steps to do that include:

- Implement a function called `run()` in `ProcGlobal` context taking no parameters.
  This function must perform all necessary steps for test execution,
  which is at least one call to :cpp:func:`RunTest`.
- Put the test experiment together with your :ref:`Test Suites<TestSuite>`
  and the script `helper/autorun-test.bat` into its own folder.
- Run the batch file `autorun-test.bat`.
- Inspect the created log file.

The example batch files for autorun create a file named `DO_AUTORUN.TXT` before starting Igor Pro.
This enables autorun mode.
After the `run()` function is executed and returned the log is saved in a file on disk and Igor Pro quits.

A different autorun mode is enabled if the file is named `DO_AUTORUN_PLAIN.TXT`.
In this mode no log file is saved after the test execution and Igor Pro does not quit.
This mode also does not use the Operation Queue.

See also :ref:`example6`.

Running in an independent module
--------------------------------

The unit-testing framework can be run itself in an independent module.
This can be required in very rare cases when the `ProcGlobal` procedures
might not always be compiled.

See also :ref:`example9`.

Handling of Abort code
----------------------

The unit-testing framework continues with the next test case after catching `Abort` and logs the abort code.
Currently differentiation of different abort conditions include
manual user aborts,
stack overflow and an
encountered `Abort` in the code.
The framwork is terminated when manually pressing the Abort button.

.. note::
   Igor Pro 6 can not differentiate between manual user aborts and programmatic abort codes.
   Pressing the Abort button in Igor Pro 6 will therefore terminate only the current test case
   and continue with the next queued test case.

Reference
---------

.. toctree::

   filelist
   grouplist
   examples

