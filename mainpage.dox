
/// @defgroup HookFunctions Default hook functions
/// Default implementation of test hook functions

/// @defgroup WaveAssertions Wave Assertions
/// Test assertions for waves

/// @defgroup VariableAssertions Variable Assertions
/// Test assertions for variables

/// @defgroup StringAssertions String Assertions
/// Test assertions for strings

/// @defgroup FolderAssertions Folder Assertions
/// Test assertions for data folders

/// @example example1-plain.ipf
/// Test suite showing the basic working principles.

///  @example example2-plain.ipf
/// Test suite with run routine and module/static usage.
/// See the section about [test cases](@ref secTestCase) why the function run_IGNORE() is not considered a test case.
 
/// @example example3-plain.ipf
/// Test suite emphasising the difference between the WARN, CHECK and REQUIRE assertion variants.
/// See also @ref secAssertionTypes.
 
/// @example example4-wavechecking.ipf
/// Test suite showing some test assertions for waves.
 
/// @example example5-overridehooks.ipf
/// Two test suites showing how to use test hook overrides.
/// \include example5-overridehooks-otherSuite.ipf
 
/// @example Example6/example6-automatic-invocation.ipf
/// Test suite showing how to automate testing from the command line.
/// See also @ref secAutomaticExecution.
/// \include Example6/example6-runner.ipf

/**

@mainpage

This package empowers a programmer to utilize unit testing for Igor Pro procedures and XOPs.
For a quick start have a look at the [first example](@ref example1-plain.ipf).

The basic building blocks of this package are [Assertions](@ref secAssertionTypes) (for checking if an entity fullfills some properties), [Test cases](@ref secTestCase) (group of assertions) and [Test Suites](@ref secTestSuite) (group of test cases).

Interface design and naming is inspired by the [Boost Test Library](http://www.boost.org/libs/test).
 
@section secAssertionTypes Assertion Types

Test assertions are defined for strings, variables and waves and have names with all caps. They always come in tripletts and differ how they react on a failed assertion. For example comparing two variables can be done with @ref WARN_EQUAL_VAR, @ref CHECK_EQUAL_VAR or @ref REQUIRE_EQUAL_VAR.

The following table summarizes the action on a failed assertion:
<table border>
<tr>
  <td>Type</td>
  <td>Create Log Message</td>
  <td>Increment Error Count</td>
  <td>Abort execution immediately</td>
</tr>
<tr>
  <td>WARN</td>
  <td>YES</td>
  <td>NO</td>
  <td>NO</td>
</tr>
<tr>
  <td>CHECK</td>
  <td>YES</td>
  <td>YES</td>
  <td>NO</td>
</tr>
<tr>
  <td>REQUIRE</td>
  <td>YES</td>
  <td>YES</td>
  <td>YES</td>
</tr>
</table>

The most common used assertion type is CHECK.

@section secTestCase Test Case

A test case is one of the basic building blocks grouping assertions together.

A function in a procedure file is considered a test case if it fullfills
all of the following properties:
- takes no parameters
- its name does not end with "_IGNORE"
- is either non-static or static and part of a regular module

The second rule allows advanced users to add their own helper functions in procedure
files. It is generally a good idea to make all test cases static functions and to create
one regular module per procedure file.

A single test case can be run with the @c testCase parameter of @ref RunTest.

@section secTestSuite Test Suite

A test suite is a group of test cases which belong together. Every procedure file forms a test suite.

Tests suits can not be nested, although multiple test suites can be run in a row using the fact that the parameter @c procWinList of @ref RunTest is a semicolon (";") separated list.

All test suites called in a row can be named using the @c name parameter of @ref RunTest.

@section secTestHooks Test Hooks

To ensure proper test case execution and enable book keeping of errors, a handful of functions are called before/after distinct events code.
These hook functions always come in pairs ending on "_BEGIN" and "_END".
Before the first test case of the first test suite is executed, the hook @ref TEST_BEGIN is called, therefore @ref TEST_END marks the last function being called immediately before @ref RunTest returns.
Similarly the hooks @ref TEST_SUITE_BEGIN and @ref TEST_SUITE_END are called before every test suite and after, @ref TEST_CASE_BEGIN and @ref TEST_CASE_END before and after every test case.

In case the default hook functions don't suite your needs, it is explicitly @b not advised to just adapt them. Instead use [test hook overrides](@ref secTestHooksOverride) and override them on a global or per test suite level.

@subsection secTestHooksOverride Override Test Hooks

The default test hooks can be overridden by defining your own version of the hooks suffixed with "_OVERRIDE". The override hooks for @ref TEST_BEGIN and @ref TEST_END can only be overriden by functions in ProcGlobal. The override hooks for test suites/cases can be overriden globally if they reside in ProcGlobal context, or for a specific test suite only if they are defined in the same regular module as that test suite. Overriding here means that the default test hook is @b not executed. In case you still want to have the default test hook executed, you have to call it yourself in the override function as done in this [example](@ref example5-overridehooks.ipf).

The override test hooks have to accept exactly one string parameter, which is the name of the test suite group, test suite name or test case name.

@section secAutomaticExecution Automate Test Runs

To further simplify test execution it is possible to automate test runs from the command line.
For this you have to implement a function "run()" taking no parameters. This function then must perform all necessary steps to run your test suites, which for common cases would be just one call to @ref RunTest. For each experiment a copy of the history is saved as log file.

See also @ref Example6/example6-automatic-invocation.ipf.

**/

