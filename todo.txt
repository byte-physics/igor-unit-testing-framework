- printFailInfo does not work with Threadsafe, therefore postponing the threadsafe version
- jump into debugger on error as option? this would require that we can tell the debugger to go back in the stack trace

be able to ignore failing test cases/suites
support for stubs and mocks?
parametric test cases?

Emails from Hadrin CNRS (Mai 2015):

> Here is my current version of CHECK_CLOSE_CMPLX :
> 
> //**************************************************
> //	Check that two complex numbers are close, using the CHECK_CLOSE_VAR criteria
> //		- var1 and var 2 are the complex numbers to be compared
> //		- tol and strong_and_weak have the same semantics as in CHECK_CLOSE_VAR
> //**************************************************
> Static Function CHECK_CLOSE_CMPLX(var1, var2 [tol, strong_or_weak])
> 	variable /C var1, var2
> 	variable tol, strong_or_weak
> 	
> 	//Follow CHECK_CLOSE_VAR defaults
> 	if(ParamIsDefault(tol))
> 		tol = 1e-8
> 	endif
> 	if(ParamIsDefault(strong_or_weak))
> 		strong_or_weak = 1
> 	endif
> 	
> 	//...but do it for the real and imaginary parts of complex variables.
> 	variable result = CHECK_CLOSE_VAR(real(var1), real(var2), tol=tol, strong_or_weak=strong_or_weak)
> 	result = result && CHECK_CLOSE_VAR(imag(var1), imag(var2), tol=tol, strong_or_weak=strong_or_weak)
> 	
> 	return result
> End
> 
> 
> And the reasons why I believe it is not ready for inclusion in the 
> framework in this form are...
> 
>   * Default parameters should not be duplicated the way I did it. They
>     should probably be program-wide Constants, or else all calls to
>     CHECK_CLOSE_VAR should be wrapped in
>     if..elseif...elseif..else..endif statements that check for all
>     combinations of default and non-default parameters (but that last
>     option would be bad for readability).
>   * This only implements CHECK, not WARN nor REQUIRE.
>   * If the check is implemented this way, then a check failure will be
>     reported within the body of CHECK_CLOSE_CMPLX, rather than within
>     the test case itself. This is obviously less helpful.
> 
> In short, this was fine for my needs because again I don't use many 
> complex numbers, but I wouldn't consider this code production-ready.

thanks for the code and especially the left things to be done for proper inclusion.
 
> As for the addition of FAIL() in the catch block of RunTest(), in fact 
> that's pretty much what I did. Except I did so in every single one of my 
> test cases since I didn't want to patch the framework myself, so the 
> result is obviously less elegant.
> 
> One thing to keep in mind, in this case, is that again, if FAIL() is 
> used directly, then stray Aborts will be reported by the test runner 
> within the body of RunTest(), instead of within the code being tested. I 
> don't know if there is a way to avoid this, since to the best of my 
> knowledge, Igor does not provide tracebacks for aborts. But maybe it 
> would be helpful to replace or supplement the default FAIL() behavior 
> with a more explicit warning stating that the test has failed because of 
> an abort.

Igor already supports getting info about calling fuctions, see GetRTStackInfo(3).
The code regarding printing the failed/successfull test case currently assumes a 
specfic call chain. I will change that so that you can call FAIL etc. also from within
the test cases and still get the correct function printed.
